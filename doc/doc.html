<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>ER (Enterprise RIA) 框架手册</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book" title="ER (Enterprise RIA) 框架手册"><div class="titlepage"><div><div><h1 class="title"><a name="idm105203793040"></a>ER (Enterprise RIA) 框架手册</h1></div><div><div class="author"><h3 class="author"><span class="firstname">erik<code class="email">&lt;<a class="email" href="mailto:dongrui@baidu.com">dongrui@baidu.com</a>&gt;</code></span></h3></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#idm105203785744">1. ER (Enterprise RIA)</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203782480">1.1. 什么是ER框架？</a></span></dt><dt><span class="section"><a href="#idm105203796464">1.2. ER框架的适用于什么项目？</a></span></dt><dt><span class="section"><a href="#idm105203779104">1.3. ER框架解决了什么问题？</a></span></dt><dt><span class="section"><a href="#idm105203774544">1.4. 开始之前</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idm105203770288">2. 开始：Hello world！</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203768976">2.1. 第一步：建立html</a></span></dt><dt><span class="section"><a href="#idm105203765984">2.2. 第二步：编写页面框架</a></span></dt><dt><span class="section"><a href="#idm105203764112">2.3. 第三步：编写Module和Action</a></span></dt><dt><span class="section"><a href="#idm105203760112">2.4. 第四步：建立视图模板文件</a></span></dt><dt><span class="section"><a href="#idm105203757136">2.5. 第五步：配置并完成</a></span></dt><dt><span class="section"><a href="#idm105203755488">2.6. 总结</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idm105203748912">3. 入门篇：使用ER框架</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203747856">3.1. MVC</a></span></dt><dt><span class="section"><a href="#idm105203744272">3.2. 启动ER框架</a></span></dt><dt><span class="section"><a href="#idm105203742112">3.3. location</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203741376">3.3.1. 格式定义</a></span></dt><dt><span class="section"><a href="#idm105203738368">3.3.2. 历史记录与URL敏感原理</a></span></dt><dt><span class="section"><a href="#idm105203738112">3.3.3. er.locator API参考</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203726064">3.4. controller</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203725040">3.4.1. controller的运行机制</a></span></dt><dt><span class="section"><a href="#idm105203722032">3.4.2. er.controller API参考</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203709216">3.5. Model</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203708192">3.5.1. Model声明</a></span></dt><dt><span class="section"><a href="#idm105203705264">3.5.2. er.Model API参考</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203670256">3.6. 模板</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203668816">3.6.1. 模板加载</a></span></dt><dt><span class="section"><a href="#idm105203666224">3.6.2. 模板规则</a></span></dt><dt><span class="section"><a href="#idm105203665968">3.6.3. er.template API参考</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203645360">3.7. View</a></span></dt><dt><span class="section"><a href="#idm105203642368">3.8. Module</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203637248">3.8.1. er.Module API参考</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203635040">3.9. Action</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203629216">3.9.1. 创建Action</a></span></dt><dt><span class="section"><a href="#idm105203623584">3.9.2. 配置Action</a></span></dt><dt><span class="section"><a href="#idm105203620160">3.9.3. Action的enter</a></span></dt><dt><span class="section"><a href="#idm105203618064">3.9.4. 行为初始化</a></span></dt><dt><span class="section"><a href="#idm105203614528">3.9.5. 自动加载</a></span></dt><dt><span class="section"><a href="#idm105203608880">3.9.6. Action的event</a></span></dt><dt><span class="section"><a href="#idm105203606320">3.9.7. er.Action API参考</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203582608">3.10. 权限控制与配置</a></span></dt><dt><span class="section"><a href="#idm105203577200">3.11. 使用ESUI</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203576400">3.11.1. ESUI简介</a></span></dt><dt><span class="section"><a href="#idm105203574896">3.11.2. 模板中的定义语法</a></span></dt><dt><span class="section"><a href="#idm105203569184">3.11.3. 在view中定义控件属性</a></span></dt><dt><span class="section"><a href="#idm105203565744">3.11.4. 给控件绑定事件</a></span></dt><dt><span class="section"><a href="#idm105203562064">3.11.5. Model变更的实时视图刷新</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203559664">3.12. ER框架工作流程</a></span></dt><dt><span class="section"><a href="#idm105203556784">3.13. 开发规范</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203555392">3.13.1. 使用版本管理工具</a></span></dt><dt><span class="section"><a href="#idm105203554048">3.13.2. web根目录文件夹结构</a></span></dt><dt><span class="section"><a href="#idm105203552080">3.13.3. 包划分与命名</a></span></dt><dt><span class="section"><a href="#idm105203549664">3.13.4. src目录文件夹结构</a></span></dt><dt><span class="section"><a href="#idm105203540704">3.13.5. 开发时的管理</a></span></dt><dt><span class="section"><a href="#idm105203528944">3.13.6. 打包与压缩</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#idm105203748688">4. 进阶篇：扩展ER框架</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203526192">4.1. Action扩展</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203525008">4.1.1. 通过extend扩展Action</a></span></dt><dt><span class="section"><a href="#idm105203522560">4.1.2. 通过继承扩展Action</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203520496">4.2. View扩展</a></span></dt><dt><span class="section"><a href="#idm105203518752">4.3. 自定义route规则</a></span></dt></dl></dd></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>3.1. <a href="#idm105203733712">er.locator静态方法</a></dt><dt>3.2. <a href="#idm105203721280">er.controller静态方法</a></dt><dt>3.3. <a href="#idm105203704464">er.Model初始化参数</a></dt><dt>3.4. <a href="#idm105203703008">er.Model实例方法</a></dt><dt>3.5. <a href="#idm105203691664">er.Model初始化参数</a></dt><dt>3.6. <a href="#idm105203690208">er.Model初始化参数 (非object形式)</a></dt><dt>3.7. <a href="#idm105203685728">er.Model.Loader实例方法</a></dt><dt>3.8. <a href="#idm105203654032">er.locator静态方法</a></dt><dt>3.9. <a href="#idm105203636576">er.Module初始化参数</a></dt><dt>3.10. <a href="#idm105203605680">er.Action初始化 - option参数</a></dt><dt>3.11. <a href="#idm105203594016">er.Action 实例方法</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>3.1. <a href="#idm105203743072">启动ER框架</a></dt><dt>3.2. <a href="#idm105203706448">er.Model:实例化</a></dt><dt>3.3. <a href="#idm105203667504">配置模板文件</a></dt><dt>3.4. <a href="#idm105203664736">简单模板</a></dt><dt>3.5. <a href="#idm105203663136">变量替换过滤器</a></dt><dt>3.6. <a href="#idm105203661440">通过import进行模板复用</a></dt><dt>3.7. <a href="#idm105203659616">通过master进行模板复用</a></dt><dt>3.8. <a href="#idm105203657408">模板中的逻辑分支</a></dt><dt>3.9. <a href="#idm105203655760">模板中的循环</a></dt><dt>3.10. <a href="#idm105203643488">er.View: 创建View实例</a></dt><dt>3.11. <a href="#idm105203640416">er.Module: 声明业务模块</a></dt><dt>3.12. <a href="#idm105203627840">er.Action: 声明Action</a></dt><dt>3.13. <a href="#idm105203622304">配置Action</a></dt><dt>3.14. <a href="#idm105203607744">Action的事件</a></dt><dt>3.15. <a href="#idm105203572352">模板中声明UI组件</a></dt><dt>3.16. <a href="#idm105203567744">在view中定义控件属性</a></dt><dt>3.17. <a href="#idm105203564368">给控件绑定事件</a></dt><dt>3.18. <a href="#idm105203560816">Model变更的实时视图刷新</a></dt><dt>4.1. <a href="#idm105203516096">自定义route规则</a></dt></dl></div><div class="chapter" title="Chapter 1. ER (Enterprise RIA)"><div class="titlepage"><div><div><h2 class="title"><a name="idm105203785744"></a>Chapter 1. ER (Enterprise RIA)</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#idm105203782480">1.1. 什么是ER框架？</a></span></dt><dt><span class="section"><a href="#idm105203796464">1.2. ER框架的适用于什么项目？</a></span></dt><dt><span class="section"><a href="#idm105203779104">1.3. ER框架解决了什么问题？</a></span></dt><dt><span class="section"><a href="#idm105203774544">1.4. 开始之前</a></span></dt></dl></div><div class="section" title="1.1. 什么是ER框架？"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203782480"></a>1.1. 什么是ER框架？</h2></div></div></div><p>ER是一套用于支撑富客户端应用的框架。她实现了前进后退的历史管理、Hash定位器、path与action的映射、运行时的数据管理容器、简易的html模板、状态保持、权限管理等功能。通过er框架可以很方便地构建一个AJAX应用。</p></div><div class="section" title="1.2. ER框架的适用于什么项目？"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203796464"></a>1.2. ER框架的适用于什么项目？</h2></div></div></div><p>ER框架仅适用于整站式Ajax应用。</p><p>对于一些专属领域系统（如OA/ERP/CRM等），使用ajax技术构建网站能够带来较好的用户体验，提升系统相应速度，减少冗余数据传输降低带宽消耗。</p><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>整站式Ajax应用不利于搜索引擎抓取。故ER框架不适用于内容提供的WEB站点。</p></div></div><div class="section" title="1.3. ER框架解决了什么问题？"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203779104"></a>1.3. ER框架解决了什么问题？</h2></div></div></div><p>虽然众所周知Ajax技术给Web的体验带来了新的模式，但是开发与维护成本的增加是比较麻烦的。ER框架主要解决了如下核心问题：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>封装了hash变更页面不刷新的特性，支持前进后退历史记录堆栈与URL敏感。</p></li><li class="listitem"><p>自动完成location到Javascript Function的映射，开发者只需要关心具体的逻辑处理。</p></li><li class="listitem"><p>在框架的业务支持层面实现了MVC封装，便于代码分离与多人协同开发。</p></li><li class="listitem"><p>通过ESUI组件库，提供对复杂交互的支持。</p></li></ol></div></div><div class="section" title="1.4. 开始之前"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203774544"></a>1.4. 开始之前</h2></div></div></div><p>虽然ER框架很大程度降低了开发的复杂度，但是开始使用ER框架之前，你应该了解一些基础知识。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>了解MVC模式。</p></li><li class="listitem"><p>懂得使用HTML和CSS进行页面布局。</p></li><li class="listitem"><p>了解Javascript语言和基本的DOM操作。</p></li><li class="listitem"><p>了解JSON。</p></li><li class="listitem"><p>懂得使用任意一个Web Server。可以是apache、nginx、tomcat、lighttpd、IIS等。</p></li></ol></div></div></div><div class="chapter" title="Chapter 2. 开始：Hello world！"><div class="titlepage"><div><div><h2 class="title"><a name="idm105203770288"></a>Chapter 2. 开始：Hello world！</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#idm105203768976">2.1. 第一步：建立html</a></span></dt><dt><span class="section"><a href="#idm105203765984">2.2. 第二步：编写页面框架</a></span></dt><dt><span class="section"><a href="#idm105203764112">2.3. 第三步：编写Module和Action</a></span></dt><dt><span class="section"><a href="#idm105203760112">2.4. 第四步：建立视图模板文件</a></span></dt><dt><span class="section"><a href="#idm105203757136">2.5. 第五步：配置并完成</a></span></dt><dt><span class="section"><a href="#idm105203755488">2.6. 总结</a></span></dt></dl></div><p>本章按步骤教您建立一个简单的例子：Hello world！任何复杂的应用都会经过类似的建立过程。</p><div class="section" title="2.1. 第一步：建立html"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203768976"></a>2.1. 第一步：建立html</h2></div></div></div><p>新建一个UTF-8编码的文本文件，命名为hello.html。</p><p>一个完整的标准的html包含了DOCTYPE、html、head以及body部分。ER框架依赖于tangram，所以您需要在head中引入tangram以及er框架的javascript文件。</p><p>通常一个html需要在head部分的顶端指定content-type，定义内容类型以及字符集。UTF-8更适合于国际化。</p><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;hello&lt;/title&gt;
&lt;script type="text/javascript" src="http://img.baidu.com/js/tangram-1.3.9.core.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="../src/er-2.0.0.js"&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;&lt;/body&gt;
&lt;/html&gt;</pre></div><div class="section" title="2.2. 第二步：编写页面框架"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203765984"></a>2.2. 第二步：编写页面框架</h2></div></div></div><p>在body中添加一些html，使页面有内容。ER框架默认会自动渲染页面中的一个区域，我们把这个区域称为“主区域”。</p><pre class="programlisting">&lt;body&gt;
&lt;div&gt;
    &lt;a href="#/hello~name=world"&gt;default&lt;/a&gt; | &lt;a href="#/hello~name=erik"&gt;erik&lt;/a&gt; | &lt;a href="#/hello~name=er"&gt;er&lt;/a&gt;
&lt;/div&gt;
&lt;div id="Main"&gt;&lt;/div&gt;
&lt;/body&gt;</pre></div><div class="section" title="2.3. 第三步：编写Module和Action"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203764112"></a>2.3. 第三步：编写Module和Action</h2></div></div></div><p>在body标签结束之前插入script块，编写Module和Action。您暂时不需要了解Module和Action的概念，后面的章节会有详细的说明。</p><pre class="programlisting">&lt;script&gt;
    // 声明业务模块
    var hello = new er.Module( {
        config: {
            'action': [
                {
                    path: '/hello',
                    action: 'hello.action'
                }
            ]
        }
    } );
    
    hello.action = new er.Action( {
        view: 'hello'
    } );
&lt;/script&gt;</pre><p>可以看到，我们干了两件事情：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>在Module的声明中配置了Action，使得location为/hello时自动映射到Action对象hello.action进行处理。</p></li><li class="listitem"><p>在Action中声明了使用的视图“view”。</p></li></ol></div></div><div class="section" title="2.4. 第四步：建立视图模板文件"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203760112"></a>2.4. 第四步：建立视图模板文件</h2></div></div></div><p>新建一个UTF-8编码的文本文件，命名为tpl.html。该html不需要遵循标准html，只需要填入如下内容：</p><pre class="programlisting">&lt;!-- target:hello --&gt;
hello ${name}</pre><p>“&lt;!-- target:hello --&gt;”是ER框架默认支持的模板语法，后面的章节会有详细的说明。</p><p>在第三步创建的script块中加入如下配置，ER框架会自动加载您配置的模板文件并解析。</p><pre class="programlisting">er.config.TEMPLATE_LIST = ['tpl.html'];</pre></div><div class="section" title="2.5. 第五步：配置并完成"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203757136"></a>2.5. 第五步：配置并完成</h2></div></div></div><p>您需要在适当的时候让er框架开始工作，在window.onload时调用er的init方法。</p><pre class="programlisting">
    window.onload = function () {
    er.init();
};</pre></div><div class="section" title="2.6. 总结"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203755488"></a>2.6. 总结</h2></div></div></div><p>在这个例子中，我们用了两个html文件，总共不到50行的代码，实现一个富客户端的应用。这个应用支持前进后退的功能，并且不需要关心内容的绘制过程。</p><p>hello.html</p><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;title&gt;hello&lt;/title&gt;
&lt;script type="text/javascript" src="http://img.baidu.com/js/tangram-1.3.9.core.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="../src/er-2.0.0.js"&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
    &lt;a href="#/hello~name=world"&gt;default&lt;/a&gt; | &lt;a href="#/hello~name=erik"&gt;erik&lt;/a&gt; | &lt;a href="#/hello~name=er"&gt;er&lt;/a&gt;
&lt;/div&gt;
&lt;div id="Main"&gt;&lt;/div&gt;
&lt;script&gt;
    // 声明业务模块
    var hello = new er.Module( {
        config: {
            'action': [
                {
                    path: '/hello',
                    action: 'hello.action'
                }
            ]
        }
    } );
    
    hello.action = new er.Action( {
        view: 'hello'
    } );

    er.config.TEMPLATE_LIST = ['tpl.html'];
    window.onload = function () {
        er.init();
    };
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p>tpl.html</p><pre class="programlisting">&lt;!-- target:hello --&gt;
hello ${name}</pre><p>我们经过了5个步骤创建了这个应用。这个过程看来很多，但是在实际开发中，第一、第二、第五步、以及创建Module等步骤都是可以省略的。通常我们创建一个功能界面单元，只要经过很方便的两到三步：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>创建Action。</p></li><li class="listitem"><p>在Module中配置这个Action。</p></li><li class="listitem"><p>如果没有可以复用的模板视图，则创建一个模板。（可省略的步骤）</p></li></ol></div></div></div><div class="chapter" title="Chapter 3. 入门篇：使用ER框架"><div class="titlepage"><div><div><h2 class="title"><a name="idm105203748912"></a>Chapter 3. 入门篇：使用ER框架</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#idm105203747856">3.1. MVC</a></span></dt><dt><span class="section"><a href="#idm105203744272">3.2. 启动ER框架</a></span></dt><dt><span class="section"><a href="#idm105203742112">3.3. location</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203741376">3.3.1. 格式定义</a></span></dt><dt><span class="section"><a href="#idm105203738368">3.3.2. 历史记录与URL敏感原理</a></span></dt><dt><span class="section"><a href="#idm105203738112">3.3.3. er.locator API参考</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203726064">3.4. controller</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203725040">3.4.1. controller的运行机制</a></span></dt><dt><span class="section"><a href="#idm105203722032">3.4.2. er.controller API参考</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203709216">3.5. Model</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203708192">3.5.1. Model声明</a></span></dt><dt><span class="section"><a href="#idm105203705264">3.5.2. er.Model API参考</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203670256">3.6. 模板</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203668816">3.6.1. 模板加载</a></span></dt><dt><span class="section"><a href="#idm105203666224">3.6.2. 模板规则</a></span></dt><dt><span class="section"><a href="#idm105203665968">3.6.3. er.template API参考</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203645360">3.7. View</a></span></dt><dt><span class="section"><a href="#idm105203642368">3.8. Module</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203637248">3.8.1. er.Module API参考</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203635040">3.9. Action</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203629216">3.9.1. 创建Action</a></span></dt><dt><span class="section"><a href="#idm105203623584">3.9.2. 配置Action</a></span></dt><dt><span class="section"><a href="#idm105203620160">3.9.3. Action的enter</a></span></dt><dt><span class="section"><a href="#idm105203618064">3.9.4. 行为初始化</a></span></dt><dt><span class="section"><a href="#idm105203614528">3.9.5. 自动加载</a></span></dt><dt><span class="section"><a href="#idm105203608880">3.9.6. Action的event</a></span></dt><dt><span class="section"><a href="#idm105203606320">3.9.7. er.Action API参考</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203582608">3.10. 权限控制与配置</a></span></dt><dt><span class="section"><a href="#idm105203577200">3.11. 使用ESUI</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203576400">3.11.1. ESUI简介</a></span></dt><dt><span class="section"><a href="#idm105203574896">3.11.2. 模板中的定义语法</a></span></dt><dt><span class="section"><a href="#idm105203569184">3.11.3. 在view中定义控件属性</a></span></dt><dt><span class="section"><a href="#idm105203565744">3.11.4. 给控件绑定事件</a></span></dt><dt><span class="section"><a href="#idm105203562064">3.11.5. Model变更的实时视图刷新</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203559664">3.12. ER框架工作流程</a></span></dt><dt><span class="section"><a href="#idm105203556784">3.13. 开发规范</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203555392">3.13.1. 使用版本管理工具</a></span></dt><dt><span class="section"><a href="#idm105203554048">3.13.2. web根目录文件夹结构</a></span></dt><dt><span class="section"><a href="#idm105203552080">3.13.3. 包划分与命名</a></span></dt><dt><span class="section"><a href="#idm105203549664">3.13.4. src目录文件夹结构</a></span></dt><dt><span class="section"><a href="#idm105203540704">3.13.5. 开发时的管理</a></span></dt><dt><span class="section"><a href="#idm105203528944">3.13.6. 打包与压缩</a></span></dt></dl></dd></dl></div><div class="section" title="3.1. MVC"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203747856"></a>3.1. MVC</h2></div></div></div><p>MVC(Model - View - Controller)是一种经典的软件设计模式，主要目的是将数据、逻辑控制与视图的职责分离，让他们各自处理自己的任务。</p><p>ER框架采用了这种被广泛应用在web中的模式，下面是ER框架的结构以及简单的workflow。</p><div><img src="er_package.jpg"></div><div><img src="er_workflow_base.jpg"></div></div><div class="section" title="3.2. 启动ER框架"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203744272"></a>3.2. 启动ER框架</h2></div></div></div><p>通过调用er.init方法可以启动ER框架。通常我们在页面的底部（body标签结束之前）或者页面加载完成时（window.onload或者DOM）</p><div class="example"><a name="idm105203743072"></a><p class="title"><b>Example 3.1. 启动ER框架</b></p><div class="example-contents"><pre class="programlisting">......html内容
    &lt;script&gt;er.init();&lt;/script&gt;
&lt;/body&gt;</pre></div></div><br class="example-break"></div><div class="section" title="3.3. location"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203742112"></a>3.3. location</h2></div></div></div><div class="section" title="3.3.1. 格式定义"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203741376"></a>3.3.1. 格式定义</h3></div></div></div><p>ER框架定义了“#”号后面的内容形式，并将她称作“HashLocation”。一个HashLocation由path和query两个部分组成，其中query是可以被省略的。她和一个普通的url很像，只是将连接query的“?”号变为波浪线“~”。下面是其格式定义：</p><pre class="programlisting">Locator = [ path ] [ ~ query ] 
path    = "/" [ *char *( "/" *char) ] 
query    = *qchar 
char    = ALPHA | DIGIT 
qchar    = char | "&amp;" | "="</pre><p>上面的格式定义有点抽象，我们来看一个具体的HashLocation的例子：</p><pre class="programlisting">/book/list~page=1&amp;pageSize=15</pre></div><div class="section" title="3.3.2. 历史记录与URL敏感原理"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203738368"></a>3.3.2. 历史记录与URL敏感原理</h3></div></div></div><p>访问一个传统的网站，我们可以通过浏览器的前进后退键来访问我们曾访问过的历史页面，我们也可以在地址栏输入一个url到达特定的资源页面。而对于一个AJAX的应用，由于所有的操作都在一个页面完成，前进后退按钮通常无法回到之前的页面状态，而我们也没法通过输入url到达特定的地方。</p><p>ER框架实现了浏览历史记录与url敏感的功能，让富客户端的AJAX应用在体验上与传统web应用保持一致，遵循用户的浏览习惯。</p><p>在浏览器中，更改url“#”号后面的hash内容时，页面不会发生跳转重新请求。ER框架就是利用了这点，在hash中记录历史和实现url敏感。当然，框架屏蔽了浏览器之间的差异性。</p><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>在Ajax应用中，跳转链接a标签的href属性应该写成“#location”的形式。而且我们可以发现，即使用户选择“在新窗口中打开”，依然能够到达正确的位置。这就是url敏感和链接的混合效应给我们带来的好处。</p></div></div><div class="section" title="3.3.3. er.locator API参考"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203738112"></a>3.3.3. er.locator API参考</h3></div></div></div><div class="table"><a name="idm105203733712"></a><p class="title"><b>Table 3.1. er.locator静态方法</b></p><div class="table-contents"><table summary="er.locator静态方法" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">{string} getLocation( {void} )</td><td align="left">获取当前的Location</td></tr><tr><td align="left">{void} redirect( {string} loc )</td><td align="left">转向到Location</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" title="3.4. controller"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203726064"></a>3.4. controller</h2></div></div></div><p>controller作为中心控制器，控制整体界面的业务逻辑。</p><div class="section" title="3.4.1. controller的运行机制"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203725040"></a>3.4.1. controller的运行机制</h3></div></div></div><p>controller认为，页面上应该有一个DOM元素，作为主区域。在location发生变更的时候，controller根据path查找到相应的Action，然后执行Action的enter动作。</p><p>在这个过程中，Action负责当前业务逻辑，整合视图与数据模型。</p><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>如果path未发生变化，controller将直接对当前的Action，重新执行enter动作。</p></div><p>controller可以在非主区域DOM元素上加载并执行Action的行为。</p></div><div class="section" title="3.4.2. er.controller API参考"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203722032"></a>3.4.2. er.controller API参考</h3></div></div></div><div class="table"><a name="idm105203721280"></a><p class="title"><b>Table 3.2. er.controller静态方法</b></p><div class="table-contents"><table summary="er.controller静态方法" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">{void} fireEvent( {string}type, {Object}eventArg, {string|Object}opt_actionRuntime )</td><td align="left">fireAction的事件</td></tr><tr><td align="left">{void} fireMain( {string}type, {Object}eventArg)</td><td align="left">fire主Action的事件</td></tr><tr><td align="left">{string|Object} loadSub( {string}domId, {string}actionName, {Object}opt_argMap )</td><td align="left">在子区域加载Action</td></tr><tr><td align="left">{string|Object} loadSubByPath( {string}domId, {string}path, {Object}opt_argMap )</td><td align="left">根据path在子区域加载Action</td></tr><tr><td align="left">{void} unloadSub( {string|Object}actionRuntime )</td><td align="left">卸载action</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" title="3.5. Model"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203709216"></a>3.5. Model</h2></div></div></div><p>Model作为数据模型，用于业务逻辑相关的数据保持与处理。</p><div class="section" title="3.5.1. Model声明"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203708192"></a>3.5.1. Model声明</h3></div></div></div><p>在ER中，Model为er.Model的实例。初始化的LOADER_LIST项用于配置加载器的列表。加载器是er.Model.Loader的实例。</p><p>加载中调用set方法向模型中填充数据。加载过程可能是异步的，比如通过XMLHttpRequest从server获取数据。可以通过stop和start方法控制加载动作。</p><div class="example"><a name="idm105203706448"></a><p class="title"><b>Example 3.2. er.Model:实例化</b></p><div class="example-contents"><pre class="programlisting">new er.Model( {
    LOADER_LIST: [ 'fieldLoader', 'listLoader' ],
    
    // 同步加载过程，直接填充数据
    fieldLoader: new er.Model.Loader( function () {
        this.set( 'fields', [
            {
                title   : 'ID',
                field   : 'id',
                content : 'id',
                width   : 30,
                sortable: 1
            },
            {
                title   : '名称',
                field   : 'name',
                width   : 950,
                content : function ( item ) {
                    return item.name;
                }
            }
        ] );
    },
    
    // 异步加载过程，调用stop和start方法
    listLoader: new er.Model.Loader( function () {
        this.stop();
        var me = this;

        baidu.ajax.get( 
            'data.php?' + me.getQueryString( {
                order   : 'order',
                orderBy : 'orderBy'
            } ), 
            function ( xhr ) {
                var data = baidu.json.parse( xhr.responseText );
                me.set( 'list', data );
                me.start();
            }
        );
    } ) )
} );</pre></div></div><br class="example-break"></div><div class="section" title="3.5.2. er.Model API参考"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203705264"></a>3.5.2. er.Model API参考</h3></div></div></div><div class="table"><a name="idm105203704464"></a><p class="title"><b>Table 3.3. er.Model初始化参数</b></p><div class="table-contents"><table summary="er.Model初始化参数" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">{Array} LOADER_LIST</td><td align="left">模型loader列表</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="idm105203703008"></a><p class="title"><b>Table 3.4. er.Model实例方法</b></p><div class="table-contents"><table summary="er.Model实例方法" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">{Any} get( {string} name )</td><td align="left">获取模型数据</td></tr><tr><td align="left">{void} set( {string} name, {Any} value, {Object} opt_option )</td><td align="left">设置模型数据。option属性有silence。</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="idm105203691664"></a><p class="title"><b>Table 3.5. er.Model初始化参数</b></p><div class="table-contents"><table summary="er.Model初始化参数" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">{Array} LOADER_LIST</td><td align="left">模型loader列表</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="idm105203690208"></a><p class="title"><b>Table 3.6. er.Model初始化参数 (非object形式)</b></p><div class="table-contents"><table summary="er.Model初始化参数 (非object形式)" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">{Function} loadFunc</td><td align="left">模型加载函数</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="idm105203685728"></a><p class="title"><b>Table 3.7. er.Model.Loader实例方法</b></p><div class="table-contents"><table summary="er.Model.Loader实例方法" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">{Any} get( {string} name )</td><td align="left">获取当前模型的数据</td></tr><tr><td align="left">{void} set( {string} name, {Any} value, {Object} opt_option )</td><td align="left">设置当前模型的数据。option属性有silence。</td></tr><tr><td align="left">{void} start( {void} )</td><td align="left">启动加载行为</td></tr><tr><td align="left">{void} stop( {void} )</td><td align="left">暂停加载行为</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" title="3.6. 模板"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203670256"></a>3.6. 模板</h2></div></div></div><p>对于web系统的视图来说，浏览器解析html并展现。在ER中，html片段是通过模板文件来管理的。模板文件是一个html文本文件，可以在任何html编辑器中获得自动完成、语法高亮等功能的支持。</p><div class="section" title="3.6.1. 模板加载"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203668816"></a>3.6.1. 模板加载</h3></div></div></div><p>通过配置er.config.TEMPLATE_LIST，框架启动时（调用er.init时）会自动加载模板文件并解析。</p><div class="example"><a name="idm105203667504"></a><p class="title"><b>Example 3.3. 配置模板文件</b></p><div class="example-contents"><pre class="programlisting">er.config.TEMPLATE_LIST = [ 'tpl1.html', 'tpl2.html' ];</pre></div></div><br class="example-break"></div><div class="section" title="3.6.2. 模板规则"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203666224"></a>3.6.2. 模板规则</h3></div></div></div><p>ER的模板规则，是通过html注释声明的。最小粒度的html片段单位为target。模板支持常用的变量替换功能。</p><div class="example"><a name="idm105203664736"></a><p class="title"><b>Example 3.4. 简单模板</b></p><div class="example-contents"><pre class="programlisting">&lt;!-- target: hello --&gt;
&lt;span&gt;Hello &lt;em&gt;${name}&lt;/em&gt;!&lt;/span&gt;</pre></div></div><br class="example-break"><p>通常为了安全性，我们需要对内容进行编码。可以通过“|”将变量内容传递给过滤器进行处理。原生支持的过滤器有html和url。</p><div class="example"><a name="idm105203663136"></a><p class="title"><b>Example 3.5. 变量替换过滤器</b></p><div class="example-contents"><pre class="programlisting">&lt;!-- target: hello --&gt;
&lt;span&gt;Hello &lt;a href="url?id=${id|url}" target="_blank"&gt;${name|html}&lt;/a&gt;!&lt;/span&gt;</pre></div></div><br class="example-break"><p>模板支持import规则，允许引入已经存在的target模板片段，无需编写多次。</p><div class="example"><a name="idm105203661440"></a><p class="title"><b>Example 3.6. 通过import进行模板复用</b></p><div class="example-contents"><pre class="programlisting">&lt;!-- target: title --&gt;
&lt;h2&gt;${title|html}&lt;/h2&gt;

&lt;!-- target: page1 --&gt;
&lt;!-- import: title --&gt;
&lt;div class="content"&gt;......&lt;/div&gt;
</pre></div></div><br class="example-break"><p>有时我们希望多个模板的布局是一样的，但是里面内容不一样。ER框架的模板提供了对母版功能的支持，能方便的做到这种复用。相关功能的标签有master、target、contentplaceholder、content。</p><div class="example"><a name="idm105203659616"></a><p class="title"><b>Example 3.7. 通过master进行模板复用</b></p><div class="example-contents"><pre class="programlisting">&lt;!-- master: myMaster --&gt;
&lt;h2&gt;${title|html}&lt;/h2&gt;
&lt;div class="content"&gt;&lt;!-- contentplaceholder: content --&gt;&lt;/div&gt;
&lt;div class="foot"&gt;&lt;!-- contentplaceholder: foot --&gt;&lt;/div&gt;

&lt;!-- target: page1(master=myMaster) --&gt;
&lt;!-- content:content --&gt;
&lt;span&gt;Hello &lt;a href="url?id=${id|url}" target="_blank"&gt;${name|html}&lt;/a&gt;!&lt;/span&gt;

&lt;!-- content:foot --&gt;
copyright &amp;copy; erik
</pre></div></div><br class="example-break"><p>模板支持简单的if-elif-else逻辑分支，语法为if: ConditionalExpression或elif: ConditionalExpression，ConditionalExpression支持||、&amp;&amp;、relational(&gt;|&gt;=|&lt;|&lt;=|==|!=|===|!==)、!、${variable}、number、string和()括号表达式。下面是一个简单的示例。</p><div class="example"><a name="idm105203657408"></a><p class="title"><b>Example 3.8. 模板中的逻辑分支</b></p><div class="example-contents"><pre class="programlisting">&lt;!-- target: page1 --&gt;
&lt;!-- if: ${name} --&gt;
hello ${name}
&lt;!-- else --&gt;
nobody
&lt;!-- /if --&gt;

&lt;!-- if: ${number} &gt; 0 --&gt;
larger than zero
&lt;!-- elif: ${number} == 0 --&gt;
zero
&lt;!-- else --&gt;
invalid
&lt;!-- /if --&gt;
</pre></div></div><br class="example-break"><p>模板支持for as对数组中的每一项进行遍历，语法为for: ${list} as ${item},${index}，其中${index}可选。下面是一个简单的示例。</p><div class="example"><a name="idm105203655760"></a><p class="title"><b>Example 3.9. 模板中的循环</b></p><div class="example-contents"><pre class="programlisting">&lt;!-- target: page1 --&gt;
&lt;ul&gt;
&lt;!-- for: ${persons} as ${person}, ${index} --&gt;
&lt;li&gt;${index}: ${person.name}
&lt;!-- /for --&gt;
&lt;/ul&gt;
</pre></div></div><br class="example-break"></div><div class="section" title="3.6.3. er.template API参考"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203665968"></a>3.6.3. er.template API参考</h3></div></div></div><div class="table"><a name="idm105203654032"></a><p class="title"><b>Table 3.8. er.locator静态方法</b></p><div class="table-contents"><table summary="er.locator静态方法" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">{string} get( {string} name )</td><td align="left">获取指定模板target的HTML片段</td></tr><tr><td align="left">{void} merge( {HTMLElement} output, {string} tplName, {string} opt_privateContextId )</td><td align="left">合并模板与数据</td></tr><tr><td align="left">{void} parse( {string} source )</td><td align="left">解析模板</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" title="3.7. View"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203645360"></a>3.7. View</h2></div></div></div><p>View负责视图的渲染，实现数据以特定方式显示。在ER中，View是er.View的实例，其通过模板渲染和填充html，并调用UI组件库的相应接口，实现UI组件的渲染。</p><p>在通常情况下，er.View实例不用人工创建，除非有特殊的渲染要求或行为。下面是创建一个简单的View实例的例子。</p><div class="example"><a name="idm105203643488"></a><p class="title"><b>Example 3.10. er.View: 创建View实例</b></p><div class="example-contents"><pre class="programlisting">new er.View( {
        template: 'templateName'
    } );</pre></div></div><br class="example-break"></div><div class="section" title="3.8. Module"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203642368"></a>3.8. Module</h2></div></div></div><p>在系统设计的时候，我们通常会把具有一类抽象的功能集合划分到一个单独的模块，比如“book”的增删改查。而在ER框架中，我们认为一类业务功能应该归属与一个模块，这就是ER框架的“Module”概念。</p><p>声明一个应用模块，需要传入一个Javascript Object。下面是模块声明的例子:</p><div class="example"><a name="idm105203640416"></a><p class="title"><b>Example 3.11. er.Module: 声明业务模块</b></p><div class="example-contents"><pre class="programlisting">var book = new er.Module( {
        config: {
            'action': [
                {
                    path   : '/book',
                    action : 'book.list'
                }
            ]
        }
    } );</pre></div></div><br class="example-break"><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>我们使用“new er.Module”的方法声明了一个模块，并传入一个带有config属性的Javascript Object。通常Module的config成员是必须的，config属性只能用于保存Module的配置信息。在这里，我们先不关心config属性的内容。我们知道，在Javascript中，我们可以使用Object表示一个module或一个namespace。在er框架中，“new er.Module”其实还是将传入的对象返回，只是在内部向控制器进行注册，而这种声明Module的方式更容易理解。所以，在上面的例子中，book变量的引用其实就是我们传入的Javascript Object。</p></div><div class="caution" title="Caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>对于整站式Ajax系统，一个页面中包含了很多Javascript脚本，在这个时候，如果每个功能在实现时都使用全局变量，会有冲突的危险，冲突造成的结果是无法预测的，并且很难追查。所以我们最好统一管理全局变量，进行模块划分，只有顶级模块使用全局变量。</p></div><div class="section" title="3.8.1. er.Module API参考"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203637248"></a>3.8.1. er.Module API参考</h3></div></div></div><div class="table"><a name="idm105203636576"></a><p class="title"><b>Table 3.9. er.Module初始化参数</b></p><div class="table-contents"><table summary="er.Module初始化参数" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">{Object} moduleObj</td><td align="left">module对象，通常该对象包含一个具有action配置的config属性</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" title="3.9. Action"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203635040"></a>3.9. Action</h2></div></div></div><p>Action对模型与视图进行选择与匹配，完成用户行为的处理。通常他是er.Action的实例。</p><div class="section" title="3.9.1. 创建Action"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203629216"></a>3.9.1. 创建Action</h3></div></div></div><p>我们使用“new er.Action”的方法声明了一个Action对象，传入一个Javascript Object。框架会让我们的Action拥有初始化数据、渲染页面等功能。</p><div class="example"><a name="idm105203627840"></a><p class="title"><b>Example 3.12. er.Action: 声明Action</b></p><div class="example-contents"><pre class="programlisting">
    book.list = new er.Action( {
        model: book.listModel,
        view: 'book'
    } );</pre></div></div><br class="example-break"><p>在上面的例子中我们创建了一个Action，并指定了model和view。</p><p>model必须是一个er.Model的实例。</p><p>view可以是er.View的实例，但更多时候我们指定string，框架会自动使用相应target的模板进行渲染。额外地，我们可以指定一个function，返回string作为模板名。</p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>template属性可以替代view属性。template属性允许接受string作为模板名，或者function用于返回模板名。但是template属性不能接受new er.View。</p></div><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>通常我们将创建的Action对象作为所属模块的属性，这样利于对同一类资源的管理。对于创建的er.Module对象，我们可以把其看作是package。</p></div></div><div class="section" title="3.9.2. 配置Action"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203623584"></a>3.9.2. 配置Action</h3></div></div></div><p>创建完成后，我们需要在Module的config中配置这个Action。config需要包含一个名称为“action”的配置项。action配置项是一个数组，用于配置模块下的所有Action。下面回顾一下之前模块创建的例子：</p><div class="example"><a name="idm105203622304"></a><p class="title"><b>Example 3.13. 配置Action</b></p><div class="example-contents"><pre class="programlisting">
    var book = new er.Module({
        config: {
            'action': [
                {
                    path: '/book',
                    action: 'book.list'
                }
            ]
        }
    });</pre></div></div><br class="example-break"><p>在这个例子的配置中，一个配置项是一个Object，包含了path和action两个属性。含义是：指定Location的path为/book时，框架将对访问的处理交给book.list这个Action。从这个例子里我们也能看出，不同的path可以使用同一个Action进行处理，但是一个path只能有一个处理Action。</p></div><div class="section" title="3.9.3. Action的enter"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203620160"></a>3.9.3. Action的enter</h3></div></div></div><p>当用户请求被转发给Aciton后，Action开始执行一系列动作，这个过程我们称为Action的enter。</p><p>框架为Action的enter分了两个阶段：加载model和更新view。下面是Action的enter过程图。</p><div><img src="er_action_enter.jpg"></div><p>ER框架更新视图有两种模式：render和repaint。正常情况下，使用render模式更新视图，使用VIEW指定的html模板片段刷新整个视图区域。当来源Location的path与当前path相同时，ER框架认为仍处于当前Action环境中，采用repaint模式更新视图。这种机制利于数据变化时局部刷新的实现。</p></div><div class="section" title="3.9.4. 行为初始化"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203618064"></a>3.9.4. 行为初始化</h3></div></div></div><p>对于一个富客户端应用来说，在丰富的交互下，我们需要为页面的dom元素绑定一些事件处理函数，或者为页面中的控件绑定一些自定义事件的处理函数。这些交互我们称为用户行为，而交互事件的绑定我们称为“行为初始化”。</p><p>ER框架内置了一些事件，视图render的前后会分别触发onbeforerender和onafterrender事件，视图repaint的前后会分别触发onbeforerepaint和onafterrepaint事件，完成视图更新后最后会触发onentercomplete事件。行为初始化我们可以在恰当的事件中完成，常用的是onafterrender和onentercomplete。</p></div><div class="section" title="3.9.5. 自动加载"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203614528"></a>3.9.5. 自动加载</h3></div></div></div><p>通常对于一个web应用来说，为了优化http连接数，会将开发时所有javascript文件合并成一个。但是这样做的弊端是文件过大，对于网速较慢的用户，等待时间会很长。</p><p>ER框架提供了Action的自动加载机制：当location跳到相应的path时，如果相应的Action不存在，则会自动请求相应的Action文件。下面一些配置项决定了如何通过path查找到Action文件：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>er.config.ACTION_ROOT：Action的文件根路径</p></li><li class="listitem"><p>er.config.ACTION_AUTOLOAD：自动加载模式。默认不开启自动加载模式。设置为true时开启为"Module"自动加载模式，如myModule.auto对应的文件为ACTION_ROOT/myModule.js。设置为"action"时开启为"Action"自动加载模式，如myModule.auto对应的文件为ACTION_ROOT/myModule/auto.js</p></li><li class="listitem"><p>er.config.ACTION_PATH：这是一个kv表。key为action的名称；value为文件路径，相对于ACTION_ROOT。</p></li><li class="listitem"><p>通过ESUI组件库，提供对复杂交互的支持。</p></li></ol></div></div><div class="section" title="3.9.6. Action的event"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203608880"></a>3.9.6. Action的event</h3></div></div></div><p>Action支持通过fireEvent方法触发事件。通常用于页面中包含多Action区域时的交互。</p><div class="example"><a name="idm105203607744"></a><p class="title"><b>Example 3.14. Action的事件</b></p><div class="example-contents"><pre class="programlisting">
    // Action示例
    city.list = new er.Action({
        ......

        onCityChange: function ( city ) {
            this.model.set( 'city', city );
            // TODO: refresh view
        }
    });
    
    // 事件触发示例
    er.controller.fireMain( 'CityChange', 2 );
    </pre></div></div><br class="example-break"></div><div class="section" title="3.9.7. er.Action API参考"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203606320"></a>3.9.7. er.Action API参考</h3></div></div></div><div class="table"><a name="idm105203605680"></a><p class="title"><b>Table 3.10. er.Action初始化 - option参数</b></p><div class="table-contents"><table summary="er.Action初始化 - option参数" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">{string} BACK_LOCATION</td><td align="left">当调用Action的back时，如果没有referer，则跳转到指定的BACK_LOCATION</td></tr><tr><td align="left">{boolean} IGNORE_STATE</td><td align="left">是否关闭状态保持的功能</td></tr><tr><td align="left">{Object} STATE_MAP</td><td align="left">要保持的状态集合。“状态名/状态默认值”形式的map</td></tr><tr><td align="left">{er.Model} model</td><td align="left">对应的数据模型对象</td></tr><tr><td align="left">{string|er.View} view</td><td align="left">模板名或对应的视图渲染对象</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="idm105203594016"></a><p class="title"><b>Table 3.11. er.Action 实例方法</b></p><div class="table-contents"><table summary="er.Action 实例方法" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">{void} refresh( {void} )</td><td align="left">刷新当前action页面，只保存需要保持的state数据</td></tr><tr><td align="left">{void} resetState( {string} opt_name )</td><td align="left">重置状态值，无参数时重置所有状态</td></tr><tr><td align="left">{Object} STATE_MAP</td><td align="left">要保持的状态集合。“状态名/状态默认值”形式的map</td></tr><tr><td align="left">{er.Model} model</td><td align="left">对应的数据模型对象</td></tr><tr><td align="left">{string|er.View} view</td><td align="left">模板名或对应的视图渲染对象</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" title="3.10. 权限控制与配置"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203582608"></a>3.10. 权限控制与配置</h2></div></div></div><p>权限管理功能通常用于需要登录的系统中。er框架提供了一个简单的模块“er.permission”，用于权限管理。该模块提供了两个方法：init和isAllow。</p><p>我们认为，在系统设计时应该对功能进行抽象，每个抽象的功能具有相应的名称。er.permission提供了对功能是否具有权限的判断入口。</p><p>首先我们要通过init方法，传输一个Javascript Object，初始化当前拥有的权限。这个Object可以具有嵌套结构。</p><pre class="programlisting">er.permission.init({
slot: {slot_list: 1},
user: {user_list: 1, user_add: 1, user_del: 1, user_edit: 1},
sys_info: 1
});</pre><p>通常，用于初始化的Object通过server端动态输出到页面中，或来自一个独立的xhr请求。经过上面的初始化，我们可以使用isAllow来判断是否具有权限。下面是一些对上面init的isAllow结果：</p><pre class="programlisting">er.permission.isAllow('sys_info'); // true
er.permission.isAllow('slot_list'); // true
er.permission.isAllow('slot_edit'); // false</pre><p>ER框架为Location提供了一种权限机制：基于path指定一个权限，当前访问者不具有这个权限时，自动跳转到其他Location。使用这个功能需要在Action配置时添加权限信息。表示权限信息的属性有两个：authority和noAuthLocation。authority指定权限名，noAuthLocation指定没有权限时的自动跳转Location。</p><pre class="programlisting">{
path: '/member/add',
action: 'member.add',
authority: 'member_add',
noAuthLocation: '/member'
}</pre></div><div class="section" title="3.11. 使用ESUI"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203577200"></a>3.11. 使用ESUI</h2></div></div></div><div class="section" title="3.11.1. ESUI简介"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203576400"></a>3.11.1. ESUI简介</h3></div></div></div><p>ESUI是一套简单的UI Library，提供一系列的控件，能满足基本页面交互功能。ESUI的api与默认视觉皮肤遵循BAIDU ECOMUI标准。下面是ESUI的结构图。</p><div><img src="esui_package.jpg"></div><p>ER框架通过extend的方式实现UI控件的渲染支持。默认支持ESUI。</p></div><div class="section" title="3.11.2. 模板中的定义语法"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203574896"></a>3.11.2. 模板中的定义语法</h3></div></div></div><p>ER框架能够渲染页面中具有特殊属性的dom元素，将其作为UI控件。下面是模板中声明UI控件的例子。</p><div class="example"><a name="idm105203572352"></a><p class="title"><b>Example 3.15. 模板中声明UI组件</b></p><div class="example-contents"><pre class="programlisting">&lt;!-- target: list --&gt;
&lt;div ui="type:Table;id:myTable;datasource:*list;fields:*fields"&gt;&lt;/div&gt;
    </pre></div></div><br class="example-break"><p>上面的例子中，具有ui属性的div将被作为控件进行渲染。ui属性的值以类似css的方式定义。</p><pre class="programlisting"> key:value[;key:value] </pre><p>在定义ui控件的属性时，必须定义控件类型type与控件标识id。</p><p>例子中“datasource:*list”是特殊的声明，意思是引用model中name为list的数据项。</p></div><div class="section" title="3.11.3. 在view中定义控件属性"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203569184"></a>3.11.3. 在view中定义控件属性</h3></div></div></div><p>有时在模板中定义ui属性时，值可能会比较长。这时候可以在view中通过UI_PROP项定义控件的属性。定义的值将通过id映射到控件。这时候我们需要手工创建er.View实例。</p><div class="example"><a name="idm105203567744"></a><p class="title"><b>Example 3.16. 在view中定义控件属性</b></p><div class="example-contents"><pre class="programlisting">
new er.View( {
    UI_PROP: {
        myTable: {
            datasource : '*list',
            fields     : '*fields'
        }
    }
} );
    </pre></div></div><br class="example-break"><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>建议在模板中定义控件的id和type，控件的其他属性通过view的UI_PROP项定义。</p></div></div><div class="section" title="3.11.4. 给控件绑定事件"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203565744"></a>3.11.4. 给控件绑定事件</h3></div></div></div><p>通常我们需要给控件绑定事件。比较合适的方法是在Action的onafterrender中绑定事件。因因为在使用控件的模式下，repaint时不会重新创建控件，只刷新控件视图，在onentercomplete绑定会造成重复绑定。</p><div class="example"><a name="idm105203564368"></a><p class="title"><b>Example 3.17. 给控件绑定事件</b></p><div class="example-contents"><pre class="programlisting">
new er.Action( {
    ......

    onafterrender: function () {
        esui.get( 'myPager' ).onchange = this.getPageChanger();
    },

    getPageChanger: function () {
        var me = this;

        return function ( page ) {
            me.model.set( 'page', page );
            me.refresh();
        };
    }
} );
    </pre></div></div><br class="example-break"><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>控件的事件处理函数最好不要放在onafterrender的function内，应提取出来，类似上面的例子中那样。</p></div></div><div class="section" title="3.11.5. Model变更的实时视图刷新"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203562064"></a>3.11.5. Model变更的实时视图刷新</h3></div></div></div><p>在使用控件的模式下，Action可以通过设置一个配置项：MODEL_SILENCE，开启或关闭model发生变更时是否实时刷新控件。该值默认为true。设置为false则model变更将实时反馈。</p><div class="example"><a name="idm105203560816"></a><p class="title"><b>Example 3.18. Model变更的实时视图刷新</b></p><div class="example-contents"><pre class="programlisting">
&lt;!-- html 模板内容 --&gt;
&lt;input type="text" ui="type:TextInput;id:myText;value:*value" /&gt;
&lt;div ui="type:Button;id:myButton"&gt;&lt;/div&gt;

// action内容
new er.Action( {
    MODEL_SILENCE: false,

    onafterrender: function () {
        esui.get( 'myButton' ).onclick = this.getBtnClickr();
    },

    getBtnClickr: function () {
        var me = this;

        return function () {
            // 设置value，引用model中value项的控件"myText"视图将实时更新
            me.model.set( 'value', 'erik' );

            // 通过silence参数设置value，"myText"视图不会实时更新
            me.model.set( 'value', 'erik2', {silence: true} );
        };
    }
} );
    </pre></div></div><br class="example-break"></div></div><div class="section" title="3.12. ER框架工作流程"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203559664"></a>3.12. ER框架工作流程</h2></div></div></div><p>在本章节开始的时候，我们看到了ER框架简单的工作流程。下面是ER框架完整的工作流程。</p><div><img src="er_workflow.jpg"></div></div><div class="section" title="3.13. 开发规范"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203556784"></a>3.13. 开发规范</h2></div></div></div><p>在使用ER框架进行开发之前，请详细阅读开发规范。本规范无法保证必须遵守，但遵守开发规范会减少开发过程中遇到的问题，让开发过程变得更有条理，系统更容易维护。</p><div class="section" title="3.13.1. 使用版本管理工具"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203555392"></a>3.13.1. 使用版本管理工具</h3></div></div></div><p>无论是团队开发还是个人开发，都应该使用版本管理工具。推荐svn 或 git。</p></div><div class="section" title="3.13.2. web根目录文件夹结构"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203554048"></a>3.13.2. web根目录文件夹结构</h3></div></div></div><p>在web根目录下，建立两个文件夹："src"与"asset"，并将html置于该目录下。这样做的好处是，上线时可以直接删除一个src目录，就将所有源代码都删除。</p><pre class="programlisting">
webroot
    |-  asset
    |-  src
        index.html
    </pre></div><div class="section" title="3.13.3. 包划分与命名"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203552080"></a>3.13.3. 包划分与命名</h3></div></div></div><p>除了顶层包，不在全局环境中声明任何变量。并为项目起一个名字，作为业务的包名，如mblog。顶层包下可以有一些Module，作为子包。</p><p>包命名采用驼峰命名法，但最好只由一个单词或代号组成。</p><pre class="programlisting">
mblog
mblog.category
mblog.blog
mblog.comment
    </pre></div><div class="section" title="3.13.4. src目录文件夹结构"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203549664"></a>3.13.4. src目录文件夹结构</h3></div></div></div><p>src目录下主要是三种类型的资源：javascript、css、template。在ER框架中，template主要是html。</p><div class="section" title="3.13.4.1. Javascript source的管理"><div class="titlepage"><div><div><h4 class="title"><a name="idm105203548272"></a>3.13.4.1. Javascript source的管理</h4></div></div></div><p>Javascript的量最多，src下应按照Javascript来管理，并严格根据包结构对应到文件。如mblog的声明对应到src/mblog.js，mblog.blog.list的声明对应到src/mblog/blog/list.js。下面是一个文件夹结构的例子：</p><pre class="programlisting">
src
  |- mblog [dir]
        |- category [dir]
        |- blog     [dir]
        |- comment  [dir]
        |- category.js
        |- blog.js
        |- comment.js
  |- mblog.js
    </pre><p>可以看到，这样的目录结构是有冗余的，src下直接有mblog目录和mblog.js文件。但是这样做的好处有：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>方便对依赖声明进行动态加载。</p></li><li class="listitem"><p>方便打包。</p></li></ol></div></div><div class="section" title="3.13.4.2. CSS source的管理"><div class="titlepage"><div><div><h4 class="title"><a name="idm105203543760"></a>3.13.4.2. CSS source的管理</h4></div></div></div><p>CSS有一个特性：其"url(path)"中的path相对的是该当前css文件的地址，而不是访问页面的地址。所以css资源应该分开管理。如果css文件较少（1-2个），应直接置于src目录下，如果文件较多，则在src目录下有一个css目录。</p></div><div class="section" title="3.13.4.3. template的管理"><div class="titlepage"><div><div><h4 class="title"><a name="idm105203542192"></a>3.13.4.3. template的管理</h4></div></div></div><p>template通常是与业务相关的布局与内容，应放在相关业务逻辑的目录下，与相关业务的Javascript同目录。</p></div></div><div class="section" title="3.13.5. 开发时的管理"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203540704"></a>3.13.5. 开发时的管理</h3></div></div></div><div class="section" title="3.13.5.1. 引用Javascript与CSS"><div class="titlepage"><div><div><h4 class="title"><a name="idm105203539904"></a>3.13.5.1. 引用Javascript与CSS</h4></div></div></div><p>之前提到在web根目录下有asset和src目录，以及相应的html文件。开发时html应引用asset目录下的Javascript、css、template文件，这样在打包过程中html可以不做修改。</p><pre class="programlisting">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        ....
        &lt;!-- 如果在src目录中，css文件直接放在src目录下，则应引用asset/mblog.css --&gt;
        &lt;link href="asset/css/mblog.css" rel="stylesheet" type="text/css" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        ....
        &lt;script src="asset/mblog.js" type="text/javascript"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
    </pre></div><div class="section" title="3.13.5.2. 引用Javascript与CSS"><div class="titlepage"><div><div><h4 class="title"><a name="idm105203537568"></a>3.13.5.2. 引用Javascript与CSS</h4></div></div></div><p>在asset目录下相应的js与css文件中，使用document.write与@import引用src下的资源</p><pre class="programlisting">
// mblog.js
document.write( '&lt;script src="src/mblog.js" type="text/javascript"&gt;&lt;/script&gt;' );
document.write( '&lt;script src="src/mblog/category.js" type="text/javascript"&gt;&lt;/script&gt;' );
document.write( '&lt;script src="src/mblog/category/list.js" type="text/javascript"&gt;&lt;/script&gt;' );

/* mblog.css */
@import '../../src/css/mblog-category.css';
    </pre><div class="caution" title="Caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>在IE下，最多支持用@import引入32个外部css，开发时尽量不要超过这个数。</p></div></div><div class="section" title="3.13.5.3. 引用template"><div class="titlepage"><div><div><h4 class="title"><a name="idm105203534672"></a>3.13.5.3. 引用template</h4></div></div></div><p>ER框架通过{Array}er.config.TEMPLATE_LIST项来配置模板列表并自动加载，而线上环境的模板通常被打包1-3个模板文件。为区别开发时与线上环境，应在src下做两份配置：__tpl__release__.js和__tpl__debug__.js。</p><p>在开发时使用document.write的方式引用两个文件，debug文件的配置会覆盖release文件的配置，保证开发时引用的是source。</p><p>在打包脚本中通过__debug__特征过滤行，保证线上引用的是release的配置。</p><pre class="programlisting">
// asset/mblog.js 片段
document.write( '&lt;script src="src/__tpl__release__.js" type="text/javascript"&gt;&lt;/script&gt;' );
document.write( '&lt;script src="src/__tpl__debug__.js" type="text/javascript"&gt;&lt;/script&gt;' );

// src/__tpl__release__.js 片段
er.config.TEMPLATE_LIST = [ 'asset/tpl.html' ];

// src/__tpl__debug__.js 片段
er.config.TEMPLATE_LIST = [ 
    'src/mblog/blog/list.html',
    'src/mblog/comment/list.html',
    ......
];

    </pre></div><div class="section" title="3.13.5.4. 图片资源的管理"><div class="titlepage"><div><div><h4 class="title"><a name="idm105203531200"></a>3.13.5.4. 图片资源的管理</h4></div></div></div><p>图片资源应直接置于asset目录下，页面通过img标签引入的图片放在"asset/img"目录下，css用到的图片应置于asset/css/img目录下。在css source文件中先通过相对路径引用到根目录，再查找图片文件的路径。该方法避免在src和asset目录下存在两份图片文件，图片编辑时可能产生两边不一致的问题。</p><pre class="programlisting">background:url(../../asset/css/img/sprites.png);</pre></div></div><div class="section" title="3.13.6. 打包与压缩"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203528944"></a>3.13.6. 打包与压缩</h3></div></div></div><p>我们在提交测试前，需要对Javascript、CSS、template资源进行打包与压缩处理。通常我们用shell完成这个任务，因为它非常方便。下面是打包并压缩Javascript的一个例子，CSS也可以采用类似方式处理。</p><pre class="programlisting">
#! /bin/sh

currPath=$(dirname "$0")
yuipath="" #yuicompress路径
cd "$currPath"

cat asset/mblog.js | 
    awk -F'"' '/src="[^"]+.js"/{print $2}' |
            xargs cat &gt; "asset/mblog-all.js"

java -jar ${yuipath} --charset utf-8 -o asset/mblog-c.js asset/mblog-all.js

rm -f asset/mblog.js
rm -f asset/mblog-all.js
mv asset/mblog-c.js asset/mblog.js
    </pre></div></div></div><div class="chapter" title="Chapter 4. 进阶篇：扩展ER框架"><div class="titlepage"><div><div><h2 class="title"><a name="idm105203748688"></a>Chapter 4. 进阶篇：扩展ER框架</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#idm105203526192">4.1. Action扩展</a></span></dt><dd><dl><dt><span class="section"><a href="#idm105203525008">4.1.1. 通过extend扩展Action</a></span></dt><dt><span class="section"><a href="#idm105203522560">4.1.2. 通过继承扩展Action</a></span></dt></dl></dd><dt><span class="section"><a href="#idm105203520496">4.2. View扩展</a></span></dt><dt><span class="section"><a href="#idm105203518752">4.3. 自定义route规则</a></span></dt></dl></div><div class="section" title="4.1. Action扩展"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203526192"></a>4.1. Action扩展</h2></div></div></div><p>ER框架支持以两种方式扩展Action：通过extend和继承。</p><div class="section" title="4.1.1. 通过extend扩展Action"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203525008"></a>4.1.1. 通过extend扩展Action</h3></div></div></div><pre class="programlisting"> er.Action.extend( ext, opt_name ); </pre><p>通过extend扩展Action，默认情况下扩展会影响到所有的Action。opt_name是可选的别名。当指定别名时，扩展不会影响所有的Action，只会影响实例化时指定了别名的Action，例子如下：</p><pre class="programlisting"> book.list = new er.Action( {...}, opt_name ); </pre></div><div class="section" title="4.1.2. 通过继承扩展Action"><div class="titlepage"><div><div><h3 class="title"><a name="idm105203522560"></a>4.1.2. 通过继承扩展Action</h3></div></div></div><p>ER框架默认依赖Tangram JSLibrary，推荐使用T.inherits构建继承关系。下面是简单的例子：</p><pre class="programlisting">function ListAction() {}

ListAction.prototype = {
    // 你的扩展方法
};
T.inherits( ListAction, er.Action );</pre></div></div><div class="section" title="4.2. View扩展"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203520496"></a>4.2. View扩展</h2></div></div></div><p>ER框架仅支持通过extend方式扩展View，并且扩展会影响到所有的View。ER框架对UI控件渲染的支持就是通过View的extend实现的。相关写法请参考src/er/extend/ui.js。</p><pre class="programlisting"> er.View.extend( ext ); </pre></div><div class="section" title="4.3. 自定义route规则"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm105203518752"></a>4.3. 自定义route规则</h2></div></div></div><p>ER框架允许通过er.router.add方法，增加自己的route规则，将location转发给相应的function进行处理。</p><p>通常，router将转发权交给Controller，Controller再转发给Action，Action负责处理具体请求以及Model、View的整合。增加自己的route规则和function可以抛弃ER框架提供的MVC模式，自定义自己的请求处理模式。</p><p>er.router.add方法接收两个参数。第一个是RegExp类型的参数，匹配上的location将被转发给第二个参数处理。第二个参数是一个Function，Function的参数是第一个RegExp匹配到string的挨个值。</p><div class="example"><a name="idm105203516096"></a><p class="title"><b>Example 4.1. 自定义route规则</b></p><div class="example-contents"><pre class="programlisting"> er.router.add( /^:([0-9]+):([0-9]+)$/, function ( loc, one, two ) {
                document.body.innerHTML = parseInt( one, 10 ) + parseInt( two, 10 );
            }); </pre></div></div><br class="example-break"></div></div></div></body></html>
